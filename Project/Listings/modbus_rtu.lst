C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX2_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX2_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX2_buf, rs485.RX2_rev_cnt-2);
  24   2              rccrc = (rs485.RX2_buf[rs485.RX2_rev_cnt-2]) | (rs485.RX2_buf[rs485.RX2_rev_cnt-1]<<8);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX2_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX2_buf[0] == MY_ADDR )
  34   3                  {
  35   4                      switch ( rs485.RX2_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3();
  39   5                              break;
  40   5      
  41   5                          case 0x06:
  42   5                              Modbus_Fun6();
  43   5                              break;  
  44   5      
  45   5                          case 0x10:  
  46   5                              Modbus_Fun16();
  47   5      
  48   5                          default:
  49   5                              break;
  50   5                      }
  51   4                  }
  52   3              }
  53   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 2   

  54   1      }
  55          
  56          /**
  57           * @brief       读输出寄存器  03
  58           *
  59           * @param   void
  60           *
  61           * @return  void 
  62          **/
  63          void Modbus_Fun3( void )
  64          {
  65   1          uint16_t i;
  66   1      
  67   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
  68   1          modbus.byte_cnt   = (rs485.RX2_buf[4]<<8 | rs485.RX2_buf[5]) *2;
  69   1          modbus.start_addr = rs485.RX2_buf[2]<<8 | rs485.RX2_buf[3];
  70   1      
  71   1          rs485.TX2_buf[0]  = MY_ADDR;                //Addr
  72   1          rs485.TX2_buf[1]  = 0x03;                   //Fun
  73   1          rs485.TX2_buf[2]  = modbus.byte_cnt;        //Byte Count
  74   1          
  75   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
  76   1          {
  77   2              /*    每次循环前初始化byte_info                       */
  78   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  79   2              switch (i)
  80   2              {
  81   3                  /*  0x00                  */
  82   3                  case 0:
  83   3                      modbus.byte_info_H  = 0X00;
  84   3                      modbus.byte_info_L  = 0X00;   
  85   3      
  86   3                      break;
  87   3      
  88   3                  /*  0x01  NTC1、NTC2温度查询                           */
  89   3                  case 1:
  90   3                      modbus.byte_info_L = temp.temp_alarm_value1;
  91   3                      modbus.byte_info_H = temp.temp_alarm_value2;   
  92   3      
  93   3                      break;
  94   3      
  95   3                  /*  0x02  NTC3温度查询                */
  96   3                  case 2:
  97   3                      modbus.byte_info_H = 0X00;   
  98   3                      modbus.byte_info_L = temp.temp_alarm_value3;
  99   3      
 100   3                      break;
 101   3      
 102   3                  /*  0x03 环境温湿度查询                   */
 103   3                  case 3:
 104   3                      modbus.byte_info_H = 0x41;           
 105   3                      modbus.byte_info_L = 0x19;          
 106   3                      // modbus.byte_info_L = get_temp(NTC_1);
 107   3                      // modbus.byte_info_H = get_temp(NTC_3);  
 108   3                      break;
 109   3      
 110   3                  /*  0x04 LED、三路加热使能状态                           */
 111   3                  case 4:
 112   3                      if( ac_220.ac220_out1_flag == 1 )
 113   3                      {
 114   4                          modbus.byte_info_L |= 0x01;
 115   4                      }else
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 3   

 116   3                      {
 117   4                          modbus.byte_info_L &= 0xFE;
 118   4                      }
 119   3      
 120   3                      if( ac_220.ac220_out2_flag == 1 )
 121   3                      {
 122   4                          modbus.byte_info_L |= 0x02;
 123   4                      }else
 124   3                      {
 125   4                          modbus.byte_info_L &= 0xFD;
 126   4                      }
 127   3      
 128   3                      if( ac_220.ac220_out3_flag == 1 )
 129   3                      {
 130   4                          modbus.byte_info_L |= 0x04;
 131   4                      }else
 132   3                      {
 133   4                          modbus.byte_info_L &= 0xFB;
 134   4                      }
 135   3      
 136   3                      modbus.byte_info_H = 0X00;   
 137   3      
 138   3                      break;
 139   3      
 140   3                  /*  0x05 风速、led状态查询                          */
 141   3                  case 5:
 142   3                      modbus.byte_info_L = ~DC_24V;       //LED状态 bit4
 143   3                      modbus.byte_info_L = ((PWMB_CCR7 / 184) | (modbus.byte_info_L<<3));         //风速 bit0~
             -3
 144   3                      modbus.byte_info_H = 0X00;   
 145   3      
 146   3                      break;
 147   3                  default:
 148   3                      break;
 149   3              }
 150   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 151   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 152   2          }
 153   1          slave_to_master(3 + modbus.byte_cnt);
 154   1      }
 155          
 156          
 157          /**
 158           * @brief       写单个输出寄存器  06
 159           *
 160           * @param   void
 161           *
 162           * @return  void 
 163          **/
 164          void Modbus_Fun6( void )
 165          {
 166   1          switch (rs485.RX2_buf[3])
 167   1          {
 168   2              /*  0x10  两路PWM 风速设置                 */
 169   2              case 0x10:             
 170   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);                            
 171   2                  
 172   2                  PWMB_CCR7 = PWMB_CCR8 = rs485.TX2_buf[5] * 184;
 173   2      
 174   2                  rs485.TX2_send_bytelength = 8;
 175   2      
 176   2                  DR2 = 1;                                    //485可以发送
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 4   

 177   2                  delay_ms(5);
 178   2                  S2CON |= S2TI;                              //开始发送
 179   2      
 180   2                  eeprom.pwm_info = rs485.TX2_buf[5];
 181   2                  eeprom_data_record();
 182   2      
 183   2                break;
 184   2      
 185   2              /*  0x11  LED 及 220V输出 开关状态设置                          */
 186   2              case 0x11:                                         
 187   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 188   2      
 189   2                  if( rs485.TX2_buf[5] & 0X01 )
 190   2                  {
 191   3                      DC_24V_out(1);
 192   3                  }else
 193   2                  {
 194   3                      DC_24V_out(0);
 195   3                  }
 196   2      
 197   2                  ac_220.ac220_out1_flag = ((modbus.byte_info_L >> 1) & 0x01);
 198   2                  ac_220.ac220_out2_flag = ((modbus.byte_info_L >> 2) & 0x01);
 199   2                  ac_220.ac220_out3_flag = ((modbus.byte_info_L >> 3) & 0x01);
 200   2      
 201   2                  rs485.TX2_send_bytelength = 8;
 202   2      
 203   2                  DR2 = 1;                                    //485可以发送
 204   2                  delay_ms(5);
 205   2                  S2CON |= S2TI;                              //开始发送
 206   2      
 207   2                  eeprom.led_info = rs485.TX2_buf[5];
 208   2                  eeprom_data_record();
 209   2      
 210   2                  break;
 211   2      
 212   2              /*  0x12  NTC1 NTC2 alarm value 设置                          */
 213   2              case 0x12:                                         
 214   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 215   2      
 216   2                  temp.temp_alarm_value1 = rs485.TX2_buf[5];
 217   2                  temp.temp_alarm_value2 = rs485.TX2_buf[4];
 218   2                  
 219   2                  rs485.TX2_send_bytelength = 8;
 220   2                  DR2 = 1;                                    //485可以发送
 221   2                  delay_ms(5);
 222   2                  S2CON |= S2TI;                              //开始发送
 223   2      
 224   2                  eeprom.temp_alarm_value1 = temp.temp_alarm_value1;
 225   2                  eeprom.temp_alarm_value2 = temp.temp_alarm_value2;
 226   2                  eeprom_data_record();
 227   2      
 228   2                  break;  
 229   2                  
 230   2              /*  0x13  NTC3 alarm value 设置                   */
 231   2              case 0x13:                                         
 232   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 233   2      
 234   2                  temp.temp_alarm_value3 = rs485.TX2_buf[5];
 235   2                  
 236   2                  rs485.TX2_send_bytelength = 8;
 237   2                  DR2 = 1;                                    //485可以发送
 238   2                  delay_ms(5);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 5   

 239   2                  S2CON |= S2TI;                              //开始发送
 240   2      
 241   2                  eeprom.temp_alarm_value3 = temp.temp_alarm_value3;
 242   2                  eeprom_data_record();
 243   2      
 244   2                  break;
 245   2              default:
 246   2                  break;   
 247   2          }
 248   1      }
 249          
 250          /**
 251           * @brief       写多个输出寄存器  16
 252           *
 253           * @param   void
 254           *
 255           * @return  void 
 256          **/
 257          void Modbus_Fun16( void )
 258          {
 259   1          uint16_t crc;
 260   1          uint16_t i;
 261   1      
 262   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 263   1          modbus.byte_cnt   = rs485.RX2_buf[6];
 264   1          modbus.start_addr = rs485.RX2_buf[2]<<8 | rs485.RX2_buf[3];
 265   1      
 266   1          memcpy(rs485.TX2_buf,rs485.RX2_buf,6);
 267   1          crc = MODBUS_CRC16(rs485.TX2_buf,6);
 268   1          rs485.TX2_buf[7] = crc>>8;                 //CRC H
 269   1          rs485.TX2_buf[6] = crc;                    //CRC L
 270   1      
 271   1          rs485.TX2_send_bytelength = 8;
 272   1          DR2 = 1;                                   //485可以发送
 273   1          delay_ms(2);
 274   1          S2CON |= S2TI;  
 275   1          delay_ms(1);
 276   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 277   1          {
 278   2              modbus.byte_info_H = rs485.RX2_buf[modbus.rcv_value_addr];
 279   2              modbus.byte_info_L = rs485.RX2_buf[modbus.rcv_value_addr + 1];
 280   2              switch (i)
 281   2              {
 282   3                  /*  0x10  两路PWM 开关状态及风速设置                 */
 283   3                  case 0X10:
 284   3                      PWMB_CCR7 = PWMB_CCR8 = modbus.byte_info_L * 184;
 285   3      
 286   3                      eeprom.pwm_info = modbus.byte_info_L;
 287   3                      break;
 288   3                  
 289   3                  /*  0X11  24V LED  AC220V 1\2\3开关状态设置                          */
 290   3                  case 0X11:
 291   3                      if( modbus.byte_info_L & 0X01 )
 292   3                      {
 293   4                          DC_24V_out(1);
 294   4                      }else
 295   3                      {
 296   4                          DC_24V_out(0);
 297   4                      }
 298   3                      ac_220.ac220_out1_flag = ((modbus.byte_info_L >> 1) & 0x01);
 299   3                      ac_220.ac220_out2_flag = ((modbus.byte_info_L >> 2) & 0x01);
 300   3                      ac_220.ac220_out3_flag = ((modbus.byte_info_L >> 3) & 0x01);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 6   

 301   3      
 302   3                      eeprom.led_info = modbus.byte_info_L;
 303   3                      break;
 304   3      
 305   3                  /*  0X12  NTC1 NTC2 alarm value 设置                   */
 306   3                  case 0X12:
 307   3                      temp.temp_alarm_value1 = modbus.byte_info_L;
 308   3                      temp.temp_alarm_value2 = modbus.byte_info_H;
 309   3                      
 310   3      
 311   3                      eeprom.temp_alarm_value1 = temp.temp_alarm_value1;
 312   3                      eeprom.temp_alarm_value2 = temp.temp_alarm_value2;
 313   3                      break;
 314   3      
 315   3                  
 316   3                  /*  0X13  NTC3 alarm value 设置                        */
 317   3                  case 0X13:
 318   3                      temp.temp_alarm_value3 = modbus.byte_info_L;
 319   3      
 320   3                      eeprom.temp_alarm_value3 = temp.temp_alarm_value3;
 321   3                      break;
 322   3      
 323   3                  default:
 324   3                      break;
 325   3              }
 326   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 327   2          }
 328   1          
 329   1      
 330   1      
 331   1          //DR2 = 1;                                   //485可以发送
 332   1          //delay_ms(5);
 333   1          
 334   1      
 335   1          eeprom_data_record();                      //记录更改后的值
 336   1      }
 337          
 338          /**
 339           * @brief       crc校验函数
 340           * 
 341           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 342           * @param   length:数据长度           
 343           * 
 344            @return  crc16:crc校验的值 2byte
 345           */
 346          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 347          {
 348   1              uint8_t i;
 349   1              uint16_t        crc16;
 350   1      
 351   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 352   1              crc16 = 0xffff; 
 353   1      
 354   1              do
 355   1              {
 356   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 357   2                      crc16 ^= (uint16_t)*buf;                //
 358   2                      for(i=0; i<8; i++)              
 359   2                      {
 360   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        04/10/2025 14:41:52 PAGE 7   

 361   3                              if(crc16 & 1)
 362   3                  {
 363   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 364   4                  }
 365   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 366   3                  else
 367   3                  {
 368   4                      crc16 >>= 1;
 369   4                  }           
 370   3                      }
 371   2                      buf++;
 372   2              }while(--length != 0);
 373   1      
 374   1              return  (crc16);
 375   1      }
 376          
 377          /**
 378           * @brief       从机回复主机
 379           *  
 380           * @param   length:数据长度           
 381           * 
 382            @return  crc16:crc校验的值 2byte
 383           */
 384          void slave_to_master(uint8_t length)
 385          {
 386   1          uint16_t crc;
 387   1      
 388   1          crc = MODBUS_CRC16(rs485.TX2_buf,length);
 389   1      
 390   1          rs485.TX2_buf[length] = crc;                 //CRC H
 391   1          rs485.TX2_buf[length+1] = crc>>8;                  //CRC L
 392   1      
 393   1          rs485.TX2_send_bytelength = length + 2;
 394   1      
 395   1          DR2 = 1;                                        //485可以发送
 396   1          delay_ms(2);
 397   1          S2CON |= S2TI;                                  //开始发送
 398   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1300    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
